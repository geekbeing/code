# 左神算法笔记-初级

###### 行列有序且递增，找数X：

方法：从右上角开始找，比X大了，往左找，比X小了，往下找；越界了或到左下角了，则X不存在。

###### 判断一个链表是否为回文结构

【 题目】 给定一个链表的头节点head， 请判断该链表是否为回
文结构。 例如： 1->2->1， 返回true。 1->2->2->1， 返回true。15->6->15， 返回true。 1->2->3， 返回false。

```
Code_11_IsPalindromeList
```

**解法1**：辅助栈，**时间O(N)，空间O(N)**

全逆序，进行比较

> - 使用一个辅助栈，遍历链表，数据入栈；
> - 二次遍历链表，同时数据出栈，逐个进行比较；
> - 全部相等则为回文；

**解法2**：快慢指针法，**时间O(N)，空间O(N/2)**

后半段逆序（**入栈**），与前半段比较

> - 慢指针走一步，快指针走两步；
> - 当快指针为空时，慢指针到达中点，慢指针数据开始入栈
> - 再次遍历链表，同时数据出栈，逐个进行比较；
> - 全部相等则为回文；

**进阶：** 如果链表长度为N， 时间复杂度达到O(N)， 额外空间复杂度达到O(1)  

**最优解：**快慢指针法，**时间O(N)，空间O(1)**

后半段逆序（**使链表逆序**），与前半段比较

> - 慢指针走一步，快指针走两步；
> - 当快指针为空时，慢指针到达中点，慢指针出开始使链表逆序；例如 1 -> 2 -> 3 <- 4 <- 5
> - 从两端遍历链表，逐个数据进行比较；
> - 全部相等则为回文；



###### 将单向链表按某值划分成左边小、 中间相等、 右边大的形式 （荷兰国旗问题）

【 题目】 给定一个单向链表的头节点head， 节点的值类型是整型， 再给定一个整 数pivot。 实现一个调整链表的函数， 将链表调整为左部分都是值小于 pivot的节点， 中间部分都是值等于pivot的节点， 右部分都是值大于 pivot的节点。
除这个要求外， 对调整后的节点顺序没有更多的要求。 例如： 链表9->0->4->5->1， pivot=3。 调整后链表可以是1->0->4->9->5， 也可以是0->1->9->5->4。 总之， 满 足左部分都是小于3的节点， 中间部分都是等于3的节点（ 本例中这个部分为空） ， 右部分都是大于3的节点即可。 对某部分内部的节点顺序不做 要求。  

**解法1：** （荷兰国旗问题）

> - 把节点存成数组，用荷兰国旗问题的方法划分；
> - 划分完把数组串成链表。



**进阶：** 在原问题的要求之上再增加如下两个要求。
在左、 中、 右三个部分的内部也做顺序要求， 要求每部分里的节点从左 到右的
顺序与原链表中节点的先后次序一致。 例如： 链表9->0->4->5->1， pivot=3。
调整后的链表是0->1->9->4->5。 在满足原问题要求的同时， 左部分节点从左到
右为0、 1。 在原链表中也 是先出现0， 后出现1； 中间部分在本例中为空， 不再
讨论； 右部分节点 从左到右为9、 4、 5。 在原链表中也是先出现9， 然后出现4，
最后出现5。
如果链表长度为N， 时间复杂度请达到O(N)， 额外空间复杂度请达到O(1)。  

**解法：** 时间O(N)， 空间O(1)

> - 使用less与end1，equal与end2，more与end3，构建三个空链表；
> - 遍历链表，根据less、equal、more，将节点插入对应链表中；
> - 将三个链表依次链接起来；

![image-20201024104814175](C:\Users\chiwai lee\AppData\Roaming\Typora\typora-user-images\image-20201024104814175.png)



###### 复制含有随机指针节点的链表

【 题目】 一种特殊的链表节点类描述如下：
public class Node { public int value; public Node next; 

public Node rand;

public Node(int data) { this.value = data; }
} 

Node类中的value是节点值， next指针和正常单链表中next指针的意义一 样， 都指向下一个节点， rand指针是Node类中新增的指针， 这个指针可 能指向链表中的任意一个节点， 也可能指向null。 给定一个由Node节点类型组成的无环单链表的头节点head， 请实现一个 函数完成这个链表中所有结构的复制， 并返回复制的新链表的头节点。



 **进阶：**不使用额外的数据结构， 只用有限几个变量， 且在时间复杂度为 O(N)内完成原问题要实现的函数。  



###### 两个单链表相交的一系列问题

【 题目】 在本题中， 单链表可能有环， 也可能无环。 给定两个单链表的头节点 head1和head2， 这两个链表可能相交， 也可能不相交。 请实现一个函数， 如果两个链表相交， 请返回相交的第一个节点； 如果不相交， 返回null 即可。 要求： 如果链表1的长度为N， 链表2的长度为M， 时间复杂度请达到 O(N+M)， 额外空间复杂度请达到O(1)。  

**子问题1**. 判断单链表是否有环，有则输出第一个入环的节点

**解法1：**用Hashset/map

> - 遍历链表，逐个判断set 中是否存在？不存在则存入key；
>
> - 若遇到null，则无环。
>
> - 第一个重复的节点就是第一个入环的节点；
>
>   

**解法2：**快慢指针法

> - 慢指针走一步，快指针走两步；
> - 若快指针遇到null，则无环。
> - 若两个指针相遇时，快指针从头节点开始遍历，快慢指针每次都走一步；
> - 两个指针再次相遇时，该节点就是第一个入环的节点。



**子问题2.** 判断两个无环单链表是否相交

**解法1：**用Hashset/map

> - 遍历链表1存入map中；
> - 遍历链表2，判断节点是否存在map中；
> - 若不存在，则两链表不相交；
> - 第一个存在的节点即为相交的第一个节点。

**解法2：**

> - 遍历两个链表获得len1、end1和len2、end2；
> - 若end1 != end2， 则不相交；
> - 把长的链表移动多出来的长度，然后两个链表同时遍历，第一个相遇的节点就是相交的第一个节点。



**子问题3**. 判断两个有环链表是否相交，相交则返回相交的第一个节点

分析：此时只存在以下三种情况

![image-20201024120803329](C:\Users\chiwai lee\AppData\Roaming\Typora\typora-user-images\image-20201024120803329.png)

**解法：**

> - 通过子问题的方法分别获得两个链表的头节点head和第一个入环节点loop；
> - 若 loop1 = loop2，两链表为拓扑结构2，则用子问题2的方法获得head到loop的链表的相交的第一个节点。
> - 若 loop1 != loop2，两链表为拓扑结构1或者3；
> - 让 loop1继续遍历；
> - 若遇到 loop2，则两链表为拓扑结构3，相交的第一个节点为 loop1 或 loop2；
> - 若未遇到 loop2，则两链表为拓扑结构1，两链表不相交。



###### 二叉树前序、中序、后序遍历

**递归：**

```java
public static void OrderRecur(Node head) {
		if (head == null) {
			return;
		}
		System.out.print(head.value + " "); // prepreOrderRecur
		preOrderRecur(head.left); 
    	//System.out.print(head.value + " "); // inpreOrderRecur
		preOrderRecur(head.right);
    	//System.out.print(head.value + " "); // pospreOrderRecur
	}
```



**非递归:** 使用辅助栈

**前序遍历**

> - 头节点入栈
> - 出栈一个节点，该节点的**右孩子、左孩子依次入栈**；
> - 直到结束。

```java
Stack<Node> stack = new Stack<Node>();
stack.add(head);
while (!stack.isEmpty()) {
   head = stack.pop();
   System.out.print(head.value + " ");
   if (head.right != null) {
      stack.push(head.right);
   }
   if (head.left != null) {
      stack.push(head.left);
   }
}
```

**中序遍历**

> - 当前节点不为空，节点入栈，然后访问其左孩子；
> - 当前节点为空，出栈一个节点，打印节点，然后访问其右孩子；

```java
while (!stack.isEmpty() || head != null) {
    if (head != null) {
        stack.push(head);
        head = head.left;
    } else {
        head = stack.pop();
        System.out.print(head.value + " ");
        head = head.right;
    }
```

**后序遍历**

> - 头节点入栈s1；
> - 当s1不为空，出栈一个节点，入栈s2；
> - 若左孩子不空，则入栈s1；
> - 若右孩子不空，则入栈s1；
> - 当s1为空时，s2全部出栈，依次打印。

```java
Stack<Node> s1 = new Stack<Node>();
Stack<Node> s2 = new Stack<Node>();
s1.push(head);
while (!s1.isEmpty()) {
   head = s1.pop();
   s2.push(head);
   if (head.left != null) {
      s1.push(head.left);
   }
   if (head.right != null) {
      s1.push(head.right);
   }
}
while (!s2.isEmpty()) {
   System.out.print(s2.pop().value + " ");
}
```



###### 在二叉树中找到一个节点的后继节点

【 题目】 现在有一种新的二叉树节点类型如下：

```java
public class Node {
    public int value; 
    public Node left;
    public Node right; 
    public Node parent;
    public Node(int data) { 
    	this.value = data; 
    }
} 
```

该结构比普通二叉树节点结构多了一个指向父节点的parent指针。 假设有一 棵Node类型的节点组成的二叉树， 树中每个节点的parent指针都正确地指向 自己的父节点， 头节点的parent指向null。 只给一个在二叉树中的某个节点 node， 请实现返回node的后继节点的函数。 在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点。  

**分析：**

1. 有右子树时，其后继节点为其右子树上最左边的节点；
2. 无右子树时， 判断当前节点是否为其父节点的左孩子，若不是则往父节点继续找；若是则此父节点为所求后继节点。

```java
if (node.right != null) {
   return getLeftMost(node.right);
} else {
   Node parent = node.parent;
   while (parent != null && parent.left != node) {
      node = parent;
      parent = node.parent;
   }
   return parent;
}
```



**拓展**：寻找一个节点的前驱

**分析：**

1. 有左子树时，其前驱节点为其左子树的最右边的节点；
2. 无左子树时，判断当前节点是否为其父节点的右孩子，若不是则往父节点继续找；若是则次父节点为所求前驱。



###### 二叉树的序列化和反序列化

```Code_04_SerializeAndReconstructTree```

**二叉树的序列化**

分析：

> - 遍历二叉树
> - 不空，输出  "值_" ；
> - 空，输出 "#_"。

```java
public static Node reconByPreString(String preStr) {
   String[] values = preStr.split("!");
   Queue<String> queue = new LinkedList<String>();
   for (int i = 0; i != values.length; i++) {
      queue.offer(values[i]);
   }
   return reconPreOrder(queue);
}
```



**二叉树的反序列化**

分析：如何序列化的就如何反序列化

```java
public static Node reconPreOrder(Queue<String> queue) {
   String value = queue.poll();
   if (value.equals("#")) {
      return null;
   }
   Node head = new Node(Integer.valueOf(value));
   head.left = reconPreOrder(queue);
   head.right = reconPreOrder(queue);
   return head;
}
```



###### 判断一棵二叉树是否是平衡二叉树

==**二叉树通用递归套路**== 树型DP

```
列出可能性；
确定返回值类型； 
递归{
    （决策过程）
    边界返回；
    得到子树信息；
    整合子树信息；
    加工出我的信息；
    往上返回；
}
```

```java
public static int getHeight(Node head, int level, boolean[] res) {
    if (head == null) {
        return level;
    }
    int lH = getHeight(head.left, level + 1, res);
    if (!res[0]) {
        return level;
    }
    int rH = getHeight(head.right, level + 1, res);
    if (!res[0]) {
        return level;
    }
    if (Math.abs(lH - rH) > 1) {
        res[0] = false;
    }
    return Math.max(lH, rH);
}
```



###### 判断一棵树是否是搜索二叉树、 判断一棵树是否是完全二叉树

**判断一棵树是否是搜索二叉树**

**分析：**

> - 中序遍历，每个元素都比前一个元素大。
> - 非递归版本比递归版本好改，在把打印元素改为与前元素比较；



**判断一棵树是否是完全二叉树**

**分析：**判断条件

> - 如果只有右孩子，直接返回false；
> - 从第一个孩子不全的节点的下一个节点开始，之后全是叶子节点。



4

1110



###### 已知一棵完全二叉树， 求其节点的个数

要求： 时间复杂度低于O(N)， N为这棵树的节点个数  

**分析：**

> - 
> - 若右子树到达了最底层，则左子树为满二叉树，除右子树外节点数为 2^n ；然后递归右子树；
> - 若右子树未到达最底层，则右子树为满二叉树，除左子树外节点数为 2^n；然后递归左子树；
> - 时间O((logN)^2)

```java
public static int bs(Node node, int level, int h) {
   // level 节点Node所在层，h 树的总高度
   if (level == h) {
      return 1;
   }
   if (mostLeftLevel(node.right, level + 1) == h) {
      return (1 << (h - level)) + bs(node.right, level + 1, h);
   } else {
      return (1 << (h - level - 1)) + bs(node.left, level + 1, h);
   }
}
```



##### 初6

哈希函数

例如：大数据文件，查重，哈希函数进行分流



###### 6.1 设计RandomPool结构

【 题目】 设计一种结构， 在该结构中有如下三个功能：

insert(key)： 将某个key加入到该结构， 做到不重复加入。

delete(key)： 将原本在结构中的某个key移除。 

getRandom()：等概率随机返回结构中的任何一个key。

【 要求】 Insert、delete和 getRandom方法的时间复杂度都是O(1) 

​	

###### 6.2 布隆过滤器

用于解决爬虫去重，黑名单问题

有小的错误率



**黑名单问题**

**哈希方法：**

- URL ->  hash -> hash code % m -> 0 ~ m-1 的位置(bit)

**布隆过滤器：**

- URL ->  k 个 hash -> 描黑对应k个bit ->  生成黑名单
- 查黑名单：URL ->  k 个 hash -> 获得对应k个bit ->  全黑则在黑名单；不全黑则不在黑名单

注：

1. bit 类型数组长度m与**样本量**、**失误率**有关
2. bit 数组长度m为  $m = - (n*ln p)/(ln2)^2$ ，p为预期失误率，n为样本量
3. hash函数个数k 为   k = ln2 * m / n ，经典值为13
4. 真实失误率 



###### 一致性哈希

应用：所有需要集群化抗压力的，都进行了一致性哈希的改造

![image-20201025170815269](C:\Users\chiwai lee\AppData\Roaming\Typora\typora-user-images\image-20201025170815269.png)



添加机器，数据迁移代价极低

![image-20201025171451071](C:\Users\chiwai lee\AppData\Roaming\Typora\typora-user-images\image-20201025171451071.png)



出现负载均衡问题

1. 初始机器负载不均衡
2. 新增机器后负载不均衡



解决方法：

引入虚拟节点，每个物理机器对应N个虚拟节点，由路由表决定虚拟节点所对应的物理机器。

![image-20201025172644261](C:\Users\chiwai lee\AppData\Roaming\Typora\typora-user-images\image-20201025172644261.png)





##### 基7

###### 认识并查集结构  

1. 快速查找两个元素是否属于一个集合，isSameSet(A, B)
2. 合并两个元素各自的所属的集合，union(A, B)



查找与合并52

![image-20201028155335801](C:\Users\chiwai lee\AppData\Roaming\Typora\typora-user-images\image-20201028155335801.png) 



###### 岛问题(难)

【题目】一个矩阵中只有0和1两种值， 每个位置都可以和自己的上、 下、 左、 右四个位置相连， 如果有一片1连在一起， 这个部分叫做一个岛， 求一个矩阵中有多少个岛？
举例：
0 0 1 0 1 0
1 1 1 0 1 0
1 0 0 1 0 0
0 0 0 0 0 0
这个矩阵中有三个岛。  



**解法1： DFS思想，感染函数**

> - 遍历每一个节点；
> - 当前节点为1，则进入感染函数；
> - 感染函数：节点为1则感染为2，然后递归地对其上下左右节点进行感染；其他情况则跳过；
> - 感染结束，岛的数量加1；
> - 继续遍历下一个节点。

![image-20201028161719919](C:\Users\chiwai lee\AppData\Roaming\Typora\typora-user-images\image-20201028161719919.png)

```java
public static int countIslands(int[][] m) {
    if (m == null || m[0] == null) {
        return 0;
    }
    int N = m.length;
    int M = m[0].length;
    int res = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (m[i][j] == 1) {
                res++;
                infect(m, i, j, N, M);
            }
        }
    }
    return res;
}

public static void infect(int[][] m, int i, int j, int N, int M) {
    if (i < 0 || i >= N || j < 0 || j >= M || m[i][j] != 1) {
        return;
    }
    m[i][j] = 2;
    infect(m, i + 1, j, N, M);
    infect(m, i - 1, j, N, M);
    infect(m, i, j + 1, N, M);
    infect(m, i, j - 1, N, M);
}
```



**解法2：** 并行计算，并查集

> - 分块；并行计算每块的岛的数量
> - 边界处理；使用并查集的方法，相邻节点为1且不是同一集合，则合并集合，岛数量-1；相邻节点为1且是同一集合或者节点值不同，则跳过。

![image-20201028170457291](C:\Users\chiwai lee\AppData\Roaming\Typora\typora-user-images\image-20201028170457291.png)





###### 前缀树

介绍前缀树
何为前缀树？ 如何生成前缀树？

> - 字符串加的过程中，总是从头节点开始；
>
> - 依次看有没有沿途的路，如果有则复用，如果没有则新建

![image-20201028171035600](C:\Users\chiwai lee\AppData\Roaming\Typora\typora-user-images\image-20201028171035600.png)

 

例子：
一个字符串类型的数组arr1， 另一个字符串类型的数组arr2。  

1. arr2中有哪些字符， 是arr1中出现的？ 请打印  
2. arr2中有哪些字符， 是作为arr1中某个字符串前缀出现的？ 请
   打印  



###### 贪心策略


# 322 [零钱兑换](https://leetcode-cn.com/problems/coin-change/)

题目：

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。



示例 1：

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```


示例 2：

```
输入：coins = [2], amount = 3
输出：-1
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/coin-change
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 解题思路

**递归：**

```
大金额通过递归获得小金额的硬币个数 + 1；
```

**动态规划：**

```
小金额通过迭代逐步获得大金额的硬币数
```



## 递归 + 备忘录

```java

class Solution {

    public int coinChange(int[] coins, int amount) {
        int[] memo = new int[amount + 1];
        return change(coins, amount, memo);
    }
    public int change(int[] coins, int amount, int[] memo){

        if(amount == 0)
            return 0;
        if(amount < 0)
            return -1;

        if(memo[amount] != 0)
            return memo[amount];

        int res = amount + 1;
        int subproblem;

        for(int coin: coins){
            subproblem = change(coins, amount - coin, memo);
            if(subproblem == -1)
                continue;

            res = Math.min(res, 1 + subproblem);
        }
        
        if(res == amount + 1){
            memo[amount] = -1;            
        }
        else
            memo[amount] = res;            

        return memo[amount];
    }
}    
```



## 动态规划 + 备忘录

```java
class Solution {

    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[] memo = new int[max];

        memo[0] = 0;
        for(int i =1; i < max; i++){
            memo[i] = max;
        }

        for(int i=1; i < max; i++){
            for(int coin: coins){
                if((i-coin) < 0)
                    continue;
               
                memo[i] = Math.min(memo[i], 1 + memo[i-coin]);
            }           
        } 
        if(memo[amount] == max)
            return -1;       
        return memo[amount];
    }
}
```

